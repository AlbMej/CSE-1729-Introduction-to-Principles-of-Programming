;; stream primitives
(define-syntax cons-stream
  (syntax-rules ()
    ((cons-stream head tail)
     (cons head (delay tail)))))

(define (scale-stream k str)
  (cond ((empty-stream? str) str)
        (else (cons-stream (* (stream-car str) k) (scale-stream k (stream-cdr str))))))

(define (add-streams s1 s2)
  (cond ((and (empty-stream? s1)(empty-stream? s2))'())
        ((empty-stream? s1) s2)
        ((empty-stream? s2) s1)
        (else (cons-stream
               (+ (stream-car s1)(stream-car s2))
               (add-streams (stream-cdr s1)(stream-cdr s2))))))
  
(define (stream-map f str)
  (if (empty-stream? str)
      '()
      (cons-stream (f (stream-car str))
                   (stream-map f (stream-cdr str)))))

(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (stream-car x)
  (car x))

(define (stream-cdr x)
  (force (cdr x)))

(define empty-stream? null?)

(define (mult-streams str1 str2)
  (cond ((and (empty-stream? str1) (empty-stream? str2)) '())
        ((empty-stream? str1) zeroes)
        ((empty-stream? str2) zeroes)
        (else (cons-stream (* (stream-car str1) (stream-car str2)) (mult-streams (stream-cdr str1) (stream-cdr str2))))))

;; utiity for tracing function calls 
(define (tracer name . values)
  ;  usage: if at start of function defined (foo a b c)
  ;  put in (tracer 'foo a b c)
  ;  interesting to put into something that is delayed
  (define (display-spaced item)
    (display item)
    (display " "))
  (display-spaced name)
  (display-spaced "with parameter(s):")
  (for-each display-spaced values)
  (newline))
;;;;;;;;;;;;;;;;

(define (decode z)
  (let* ((w ( floor (- ( sqrt (* 2 z )) 1/2)))
         (t (/ (+ (* w w) w) 2))
         (x (- z t ))
         (y (+ (- w x ) 2)))
    (cons x y)))

(define (enumerate-integer-stream)
  (define (help_enum start)
    (cons-stream start (help_enum (+ start 1))))
  (help_enum 0))

(define (enumerate-from n)
  (define (help_enum start)
    (cons-stream start (help_enum (+ start 1))))
  (help_enum n))

(define (stream-filter p str)
  (cond ((empty-stream? str) '())
        ((p (stream-car str)) (cons-stream (stream-car str) (stream-filter p (stream-cdr str))))
        (else (stream-filter p (stream-cdr str)))))

(define (str-to-list str k)
  (cond ((empty-stream? str) str)
        ((= k 0) '())
        (else (cons (stream-car str) (str-to-list (stream-cdr str) (- k 1))))))

(define (stream-nth index str)
  (if (= index 1)
      (stream-car str)
      (stream-nth (- index 1) (stream-cdr str))))
"Problem 1a"
(define (decode-stream)
  (stream-map decode (enumerate-from 1)))

(define test (cons-stream 1
                          (cons-stream 2
                                       (cons-stream 3 '()))))

(stream-cdr (decode-stream))



"Problem 1b"
(str-to-list (decode-stream) 20)
;;The sum of each pair is greater than the previous pair sum

"Problem 2a"
(define (fibs-frm curr prev)
  (cons-stream curr
               (fibs-frm (+ curr prev) curr)))

(define fibs
  (cons-stream 0 (fibs-frm 1 0)))

"Problem 2b"
(define pow-seven
  (cons-stream 1 (scale-stream pow-seven 7)))

(define stream-of-seven
  (cons-stream 7 stream-of-seven))

stream-of-seven

(define pow-seven
  (cons-stream 1 (mult-streams pow-seven stream-of-seven)))
(str-to-list pow-seven 4) 

"Problem 3a"
(define ones (cons-stream 1 ones))
(define ints (cons-stream 1 (add-streams ones ints)))
(define ints2 (cons-stream 0 (add-streams ones ints2)))

(str-to-list ints2 10)

(define (factorial n)
  (if (= n 0)
      1
      (* n (factorial (- n 1)))))

(define zeroes (cons-stream 0 zeroes))
zeroes
(factorial 0)
(define (e-to-the-x-terms x)
  (if (= x 0)
      (cons-stream 1 zeroes)
      (cons-stream 1 (stream-map (lambda (n) (/ (expt x n) (factorial n))) ints))))

(define (e-to-the-x-terms x )
  (define (help_e x n)
    (if (= x 0)
        (cons-stream 1 zeroes)
        (cons-stream (/ (expt x n) (factorial n)) (help_e x (+ n 1)))))
  (help_e x 0))

(str-to-list (e-to-the-x-terms 2) 10)
;(str-to-list (etest 2) 10)

"Problem 3b"
(define (partial-sums str)
  (define (helping_psum str accterms)
    (if (empty-stream? str)
        str
        (cons-stream (+ (stream-car str) accterms)
                     (helping_psum (stream-cdr str) (+ accterms (stream-car str))))))
  (helping_psum str 0))

(define (e-to-the-x-approx x)
  (partial-sums (e-to-the-x-terms x)))

;(stream-cdr (e-to-the-x-terms 5))
;(str-to-list e-to-the-x-terms 2)

"Problem 4a"
(define (stream-merge str1 str2)
  (cond ((empty-stream? str1) str2)
        ((empty-stream? str2) str1)
        ((> (stream-car str1) (stream-car str2))
         (cons-stream
          (stream-car str2) (stream-merge str1 (stream-cdr str2))))
        ((< (stream-car str1) (stream-car str2))
         (cons-stream
          (stream-car str1) (stream-merge (stream-cdr str1) str2)))
        (else
         (cons-stream
          (stream-car str1) (stream-merge (stream-cdr str1) (stream-cdr str2))))))

;(str-to-list (stream-merge stream-of-seven ones) 10)

"Problem 4b"

(define 2s&3s
  (cons-stream 1 (stream-merge (scale-stream 2s&3s 2)
                               (scale-stream 2s&3s 3))))

(str-to-list 2s&3s 5)

(define 235-stream
  (stream-merge 2s&3s (scale-stream 2s&3s 5)))

(str-to-list 235-stream 10)


"Problem 5a"
(define (interleave s1 s2 )
  (if (empty-stream? s1 )
      s2
      (cons-stream (stream-car s1 )
                   (interleave s2 (stream-cdr s1 )))))
(define (pairs s t)
  (cons-stream
   (cons (stream-car s) (stream-car t ))
   (interleave
    (stream-map (lambda (x) (cons (stream-car s ) x ))
                (stream-cdr t ))
    (pairs (stream-cdr s) t ))))
(define pairs-stream
  (let ((naturals (stream-cdr (enumerate-integer-stream ))))
    (pairs naturals naturals )))

(str-to-list pairs-stream 10)
;The second element in each pair is no less than the first

(define (merge-weighted str1 str2 weight)
  (cond ((empty-stream? str1) str2)
        ((empty-stream? str2) str1)
        ((> (weight (stream-car str1)) (weight (stream-car str2)))
         (cons-stream
          (stream-car str2) (merge-weighted str1 (stream-cdr str2) weight)))
        ((< (weight (stream-car str1)) (weight (stream-car str2)))
         (cons-stream
          (stream-car str1) (merge-weighted (stream-cdr str1) str2 weight)))
        ((equal? (weight (stream-car str1)) (weight (stream-car str2)))
         (cons-stream
          (stream-car str1) (cons-stream (stream-car str2) (merge-weighted (stream-cdr str1) (stream-cdr str2) weight))))
        (else
         (cons-stream
          (stream-car str1) (merge-weighted (stream-cdr str1) (stream-cdr str2) weight)))))

"Problem 5b"
(define (stream-pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (stream-pairs (stream-cdr s)  t))))

(define (weighted-pairs str1 str2 weight)
  (cons-stream
   (cons (stream-car str1) (stream-car str2))
   (merge-weighted
    (stream-map (lambda (x) (cons (stream-car str1) x))
                (stream-cdr str2))
    (weighted-pairs (stream-cdr str1) str2 weight) weight)))

(define test5b (cons-stream 1
                            (cons-stream 2
                                         (cons-stream 3 '()))))
(define test25b (cons-stream 4
                             (cons-stream 5
                                          (cons-stream 6 '()))))
(str-to-list test5b 100)
(str-to-list (stream-pairs ints 2s&3s) 10)
(str-to-list (stream-pairs test5b test25b) 5)
(display "**")
;(str-to-list (weighted-pairs test5b test25b (lambda (x) (* 2 (car x)))) 9)

"Problem 5c"
(define weighted-pairs-stream
  (weighted-pairs ints ints (lambda (x) (+ (car x) (cdr x))) ))

(str-to-list weighted-pairs-stream 10)

"Problem 5d"

(define (cpw pair)
  ;pass car of stream
  (+ (expt (car pair) 3) (expt (cdr pair) 3)))
  
(define (ram-stream)
  
  (define (find-cubes str)
    (if (= (cpw (stream-car str)) (cpw (stream-car (stream-cdr str))))
        (cons-stream (list (cpw (stream-car str))
                           (stream-car str) (stream-car (stream-cdr str)))
                     (find-cubes (stream-cdr (stream-cdr str))))
        (find-cubes (stream-cdr str))))
  (find-cubes (stream-filter (lambda (x) (< (car x) (cdr x))) (weighted-pairs ints ints (lambda (x) (+ (expt (car x) 3) (expt (cdr x) 3))) ))))

(str-to-list (ram-stream) 10)

(define (ramanujan n)
  (car (stream-nth n (ram-stream))))

(ramanujan 2)

;The next five in the sequence are 4104, 13832 ,20683 ,32832 ,39312 

"Problem 6a"
( define ( interleave s1 s2 )
   ( if ( empty-stream? s1 )
        s2
        ( cons-stream ( stream-car s1 )
                      ( interleave s2 ( stream-cdr s1 )))))
( define ( pairs s t)
   ( cons-stream
     ( cons ( stream-car s) ( stream-car t ))
     ( interleave
       ( stream-map ( lambda ( x) ( cons ( stream-car s ) x ))
                    ( stream-cdr t ))
       ( pairs ( stream-cdr s) t ))))
( define pairs-stream
   ( let (( naturals ( stream-cdr ( enumerate-integer-stream ))))
      ( pairs naturals naturals )))

(str-to-list pairs-stream 20)

(define (encode-ps pair)
  (cond ((= (cdr pair) 1) (- (expt 2 (car pair)) 1))
        ((= (cdr pair) 2) (- (* 3 (expt 2 (- (car pair) 1))) 1))
        (else (+ (expt 2 (car pair)) (encode-ps (cons (car pair) (- (cdr pair) 1)))))))
;(* (floor (sqrt (floor (/ 17 2)))) 1)
;(sqrt (floor (/ n 2)))
;(expt 2 car of pair
;2^(car x) etc... if cdr pair = 1
;find pattern to figure out formula

;(define (decode-ps n)
 ; (used 2 helper to find pair (1 for first elem. and the other for second elem.)

(encode-ps (cons 1 1))
;(encode-ps (cons 1 2))
(encode-ps (cons 2 1))
;(encode-ps (cons 1 3))
;(encode-ps (cons 2 2))
(encode-ps (cons 3 1))
(encode-ps (cons 3 3))
(encode-ps (cons 1 11))

(define (decode-ps n)
  (define (decode-help n str)
  (if (= n 1)
      (stream-car str )
      (decode-help (- n 1) (stream-cdr str))))
  (decode-help n pairs-stream))

(define (decode-ps n)
  (cond ((even? n) (cons 1 (/ (+ n 2) 2)))
        (else (+ (cdr (cons 1 (/ (+ n 2) 2))) (cdr (cons 1 (/ (+ n 2) 2))) ))))
;(define (find-1st n)        
;(use 2 helper to find pair (1 for first elem. and the other for second elem.)
;lnn/lnb
;(cons 1 (/ (+ (- n 1) 2) 2))
;(ceiling (/ (floor (sqrt (floor (/ 19 2)))) 2))
; first 41 odd cars 1,2,2,3,2,3,2,4,2,3,2,4,2,3,2,5,2,3,2,4,2

;form is (cons 1 (/ (+ (- n 1) 2) 2))

(newline)
(define (decode-ps n)
    (define (get-cdr n)
  (cond ((= n 1) (cons 1 1))
        ((even? n) (cons 1 (/ (+ n 2) 2)))
        ((<= n 15) (+ (ceiling (/ (cdr (cons 1 (/ (+ (- n 1) 2) 2))) 3)) 1))
        ((> n 15) (floor (/ (- (ceiling (/ n 3)) 1) 2)))))
  (get-cdr n))

(decode-ps 20)
(decode-ps 19)
(decode-ps 17)
(decode-ps 15)
(decode-ps 13)


; form is  (+ (ceiling (/ n 3)) 1))
